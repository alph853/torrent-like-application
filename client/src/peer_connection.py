from queue import Queue
import socket
import struct
import threading
from enum import Enum
from .piece_manager import PieceManager
from .utils import TorrentUtils, MagnetUtils, ExtensionMessageType, MessageType

import bencodepy


class PeerConnection:
    def __init__(self, target_peer: dict, info_hash, piece_manager: PieceManager, my_id, extension_supported=True):
        self.in_queue = Queue()
        self.extension_supported = extension_supported

        self.my_id = my_id
        self.id = target_peer['id']        # id generated by the peer's IP and port
        self.peer_id = None                # peer id received from the handshake
        self.ip = target_peer['ip']
        self.port = target_peer['port']
        self.info_hash = info_hash
        self.piece_manager = piece_manager
        self.queue_running = True
        self.extension_message_id = 0
        self.ut_metadata_id = 3

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.init_connection()

    def init_connection(self):
        """Establish connection to the peer and start send/receive threads."""
        try:
            print(f"Connected to peer at {self.ip}:{self.port}")
            self.sock.connect((self.ip, self.port))
            self.peer_handshake()

            in_thread = threading.Thread(target=self.process_recv_messages, daemon=True)
            in_thread.start()

        except Exception as e:
            print(f"Failed to connect to peer {self.peer_id}: {e}")

    def peer_handshake(self):
        """Send base handshake message. Send an extension message if the peer supports the extension protocol."""
        reserved_bytes = MagnetUtils.get_reserved_bytes(self.extension_supported)
        handshake_message = (
            b"\x13BitTorrent protocol"
            + reserved_bytes
            + bytes.fromhex(self.info_hash)
            + self.my_id.encode('utf-8')
        )
        self.sock.send(handshake_message)
        response = self.sock.recv(68)

        if response[:20] != b"\x13BitTorrent protocol" or len(response) < 68:
            raise ValueError("Invalid base handshake response. Connection Severed")

        self.extension_supported = bool(response[25] & 0x10)
        info_hash = response[28:48]
        self.peer_id = response[48:].hex()

        if self.info_hash != info_hash:
            raise ValueError('Different info hash and peer id. Connection Severed.')

        if self.extension_supported:
            # Send extension handshake
            extension_id = ExtensionMessageType.HANDSHAKE.value
            handshake_message = {"m": {"ut_metadata": self.ut_metadata_id}}
            payload = MagnetUtils.construct_extension_payload(
                extension_id, handshake_message, self.extension_message_id)
            self.sock.send(payload)

    def process_recv_messages(self):
        """Receive message from a queue, including handling the BitTorrent protocol length prefix.
            Return the complete message, including the 4-byte length prefix, or None on failure.
        """
        while self.queue_running:
            try:
                message = self.recv_message()
                if message[4] == MessageType.EXTENDED.value:
                    self.handle_extension_message(message)
            except (ConnectionError, ValueError) as e:
                print(f"Error receiving message: {e}")
                self.queue_running = False

    def recv_message(self):
        length_prefix = self.sock.recv(4)
        if not length_prefix or len(length_prefix) < 4:
            raise ConnectionError("Incomplete message length prefix received.")

        message_length = int.from_bytes(length_prefix, byteorder="big")
        if message_length <= 0:
            raise ValueError("Invalid message length received.")

        message = b""
        while len(message) < message_length:
            chunk = self.sock.recv(min(4096, message_length - len(message)))
            if not chunk:
                raise ConnectionError("Connection closed before full message received.")
            message += chunk

        return message

    def handle_extension_message(self, message):
        """Handle an extension message from the peer."""
        payload = message[6:]
        decoded_payload = bencodepy.decode(payload)

        if decoded_payload.get(b"m") is not None:
            self.handle_extension_handshake_response(decoded_payload)
        else:
            self.extension_message_id = message[5]
            self.handle_metadata_response(payload)

    def handle_extension_handshake_response(self, decoded_payload):
        """Handle an extension message from the peer."""
        if self.piece_manager.get_metadata_size() is None:
            metadata_size = decoded_payload.get([b"metadata_size"], None)
            if metadata_size is None:
                return
            self.piece_manager.set_metadata_size(metadata_size)

        ut_metadata_id = decoded_payload[b"m"][b"ut_metadata"]
        print(f"Received extension handshake with 'ut_metadata' ID: {ut_metadata_id}")
        self.ut_metadata_id = ut_metadata_id
        self.request_next_metadata_piece()

    def handle_metadata_response(self, message):
        """Process a metadata data message from the peer."""
        bencoded_dict = message[6:]
        bencoded_end_index = bencoded_dict.find(b"ee") + 2  # Include the 'ee' ending
        decoded_message = bencodepy.decode(bencoded_dict[:bencoded_end_index])

        msg_type = decoded_message.get(b"msg_type")

        if msg_type == ExtensionMessageType.DATA.value:
            total_size = decoded_message.get(b"total_size")
            piece_index = decoded_message.get(b"piece")
            metadata_piece = bencoded_dict[bencoded_end_index:]

            self.piece_manager.set_metadata_piece(piece_index, metadata_piece)
            # Request the next piece if any are still missing
            self.request_next_metadata_piece()
            # Reject message
        elif msg_type == ExtensionMessageType.REJECT.value:
            return
        else:
            print("Invalid metadata message type received.")

    def request_next_metadata_piece(self):
        """Request the next piece of metadata if there are still pieces missing."""
        piece_idx = self.piece_manager.get_next_metadata_piece()
        if piece_idx is not None:
            self.send_metadata_request(self.ut_metadata_id, piece_idx)
        else:
            # start sending requests for pieces
            print("All metadata pieces downloaded.")

    def send_metadata_request(self, metadata_id, piece_idx):
        """Send the metadata request to a peer."""
        request_dict = {"msg_type": 0, "piece": piece_idx}
        bencoded_request = bencodepy.encode(request_dict)
        # 1 byte for message ID (20), 1 byte for extension message ID
        message_length = (len(bencoded_request) + 2)
        payload = (
            struct.pack(">Ib", message_length, MessageType.EXTENDED.value)
            + struct.pack("B", metadata_id)
            + bencoded_request
        )
        # Send the metadata request
        self.sock.send(payload)

    def terminate(self):
        """Terminate the connection and stop the send/receive threads."""
        self.queue_running = False
        self.sock.close()
