from queue import Queue
import socket
import struct
import threading
from enum import Enum
from .piece_manager import PieceManager
from .utils import TorrentUtils, MagnetUtils, ExtensionMessageType, MessageType

import bencodepy


class PeerConnection:
    def __init__(self, sock: socket.socket, target_peer: dict, piece_manager: PieceManager, extension_supported=True):
        self.in_queue = Queue()
        self.out_queue = Queue()

        self.extension_supported = extension_supported

        self.id = target_peer['id']        # id generated by the peer's IP and port
        self.peer_id = None                # peer id received from the handshake
        self.ip = target_peer['ip']
        self.port = target_peer['port']
        self.piece_manager = piece_manager
        self.queue_running = True
        self.extension_message_id = 0
        self.ut_metadata_id = 3

        self.sock = sock
        self.init_connection()
        self.next_requested_piece = None

    def init_connection(self):
        """Establish connection to the peer and start send/receive threads."""
        try:
            print(f"Connected to peer at {self.ip}:{self.port}")
            self.sock.connect((self.ip, self.port))

            in_thread = threading.Thread(target=self.process_recv_messages, daemon=True)
            in_thread.start()

            out_thread = threading.Thread(target=self.process_send_messages, daemon=True)
            out_thread.start()

        except Exception as e:
            print(f"Failed to connect to peer {self.peer_id}: {e}")

    def send_handshake_message(self, info_hash, my_id, outgoing):
        """Send base handshake message. Send an extension message if the peer supports the extension protocol."""
        if not outgoing:
            # Receive and validate the peer's handshake message
            response = self.sock.recv(68)

            self.extension_supported = bool(response[25] & 0x10)
            response_info_hash = response[28:48]
            self.peer_id = response[48:].hex()

            if response_info_hash != info_hash:
                raise ValueError('Different info hash and peer id. Connection Severed.')

        # Send the handshake message. Both outgoing and incoming connections send the same message
        reserved_bytes = MagnetUtils.get_reserved_bytes(self.extension_supported)
        handshake_message = (
            b"\x13BitTorrent protocol"
            + reserved_bytes
            + bytes.fromhex(info_hash)
            + my_id.encode('utf-8')
        )
        self.sock.send(handshake_message)

        if outgoing:
            response = self.sock.recv(68)

            if response[:20] != b"\x13BitTorrent protocol" or len(response) < 68:
                raise ValueError("Invalid base handshake response. Connection Severed")

            self.extension_supported = bool(response[25] & 0x10)
            response_info_hash = response[28:48]
            self.peer_id = response[48:].hex()

            if response_info_hash != info_hash:
                raise ValueError('Different info hash and peer id. Connection Severed.')

            if self.extension_supported:
                # Send extension handshake
                handshake_message = {"m": {"ut_metadata": self.ut_metadata_id}}
                payload = MagnetUtils.construct_extension_payload(
                    handshake_message, self.extension_message_id)
                self.sock.send(payload)

    def recv_message(self):
        length_prefix = self.sock.recv(4)
        if not length_prefix or len(length_prefix) < 4:
            raise ConnectionError("Incomplete message length prefix received.")

        message_length = int.from_bytes(length_prefix, byteorder="big")
        if message_length <= 0:
            raise ValueError("Invalid message length received.")

        message = length_prefix
        while len(message) < message_length:
            chunk = self.sock.recv(min(4096, message_length - len(message)))
            if not chunk:
                raise ConnectionError("Connection closed before full message received.")
            message += chunk

        return message

    def handle_extension_message(self, message):
        """Handle an extension message from the peer."""
        payload = message[6:]
        decoded_payload = bencodepy.decode(payload)

        if decoded_payload.get(b"metadata_size") is not None:
            self.handle_extension_handshake_request(decoded_payload)
        if decoded_payload.get(b"m") is not None:
            self.handle_extension_handshake_response(decoded_payload)
        else:
            self.extension_message_id = message[5]
            self.handle_metadata_response(payload)

    def handle_extension_handshake_request(self, decoded_payload):
        pass


    def handle_extension_handshake_response(self, decoded_payload):
        """Handle an extension message from the peer."""
        if self.piece_manager.get_metadata_size() is None:
            metadata_size = decoded_payload.get([b"metadata_size"], None)
            if metadata_size is None:
                return
            self.piece_manager.set_metadata_size(metadata_size)

        ut_metadata_id = decoded_payload[b"m"][b"ut_metadata"]
        print(f"Received extension handshake with 'ut_metadata' ID: {ut_metadata_id}")
        self.ut_metadata_id = ut_metadata_id
        self.request_next_metadata_piece()

    def handle_metadata_response(self, message):
        """Process a metadata data message from the peer."""
        bencoded_dict = message[6:]
        bencoded_end_index = bencoded_dict.find(b"ee") + 2  # Include the 'ee' ending
        decoded_message = bencodepy.decode(bencoded_dict[:bencoded_end_index])

        msg_type = decoded_message.get(b"msg_type")

        if msg_type == ExtensionMessageType.DATA.value:
            total_size = decoded_message.get(b"total_size")
            piece_index = decoded_message.get(b"piece")
            metadata_piece = bencoded_dict[bencoded_end_index:]

            self.piece_manager.set_metadata_piece(piece_index, metadata_piece)
            # Request the next piece if any are still missing
            self.request_next_metadata_piece()
            # Reject message
        elif msg_type == ExtensionMessageType.REJECT.value:
            return
        else:
            print("Invalid metadata message type received.")

    def request_next_metadata_piece(self):
        """Request the next piece of metadata if there are still pieces missing."""
        piece_idx = self.piece_manager.get_next_metadata_piece()
        if piece_idx is not None:
            self.send_metadata_request(self.ut_metadata_id, piece_idx)
        else:
            # start sending requests for pieces
            print("All metadata pieces downloaded.")


    def send_metadata_request(self, metadata_id, piece_idx):
        """Send the metadata request to a peer."""
        request_dict = {"msg_type": 0, "piece": piece_idx}
        bencoded_request = bencodepy.encode(request_dict)

        payload = MagnetUtils.construct_extension_payload(bencoded_request, metadata_id)
        self.sock.send(payload)

    def process_send_messages(self):
        """Send messages from the out queue to the peer."""
        while self.queue_running:
            try:
                message = self.out_queue.get()
                self.sock.send(message)
            except (ConnectionError, ValueError) as e:
                print(f"Error sending message: {e}")
                self.queue_running = False

    def process_recv_messages(self):
        """Receive message from a queue, including handling the BitTorrent protocol length prefix.
            Return the complete message, including the 4-byte length prefix, or None on failure.
        """
        while self.queue_running:
            try:
                message = self.recv_message()
                match message[4]:
                    case MessageType.EXTENDED.value:
                        self.handle_extension_message(message)
                    case MessageType.BITFIELD.value:
                        self.handle_bitfield_message(message)
                    case MessageType.PIECE.value:
                        self.handle_piece_message(message)
                    case MessageType.HAVE.value:
                        self.handle_have_message(message)
                    case MessageType.CHOKE.value:
                        self.handle_choke_message()
                    case MessageType.UNCHOKE.value:
                        self.handle_unchoke_message()
                    case MessageType.INTERESTED.value:
                        pass
                    case MessageType.NOT_INTERESTED.value:
                        pass
                    case MessageType.REQUEST.value:
                        pass
                    case _:
                        print(f"Unhandled message type: {message[4]}")
            except (ConnectionError, ValueError) as e:
                print(f"Error receiving message: {e}")
                self.queue_running = False

    def handle_bitfield_message(self, message):
        """Handle a bitfield message from the peer."""
        bitfield = message[5:]
        bitfield = [int(b) for b in bitfield]
        self.piece_manager.add_peer_bitfield(self.id, bitfield)

    def handle_unchoke_message(self):
        """Handle an unchoke message from the peer."""
        message = struct.pack(">IB", 1, MessageType.REQUEST.value)
        self.enqueue_send_message(message)

    def handle_choke_message(self):
        """Handle a choke message from the peer."""
        self.next_requested_piece = None

    def handle_have_message(self, message):
        """Handle a have message from the peer."""
        piece_index = struct.unpack(">I", message[5:])[0]
        self.piece_manager.add_peer_piece(self.id, piece_index)

    def handle_piece_message(self, message):
        """Handle a piece message from the peer."""
        pass

    def send_interest_message(self, piece_idx):
        """Send an interested to the peer for a specific piece."""
        message = struct.pack(">IB", 1, MessageType.INTERESTED.value)
        self.next_requested_piece = piece_idx
        self.enqueue_send_message(message)

    def enqueue_send_message(self, message):
        """Enqueue a message to be sent to the peer."""
        self.out_queue.put(message)

    def terminate(self):
        """Terminate the connection and stop the send/receive threads."""
        self.queue_running = False
        self.sock.close()
